"use strict";
// Copyright IBM Corp. 2018,2019. All Rights Reserved.
// Node module: strong-docs
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const abstract_1 = require("typedoc/dist/lib/models/reflections/abstract");
function getType(type) {
    if (type.type === 'reference') {
        const ref = type;
        return '<a href="#' + ref.name + '">' + ref.name + '</a>';
    }
    else if (type.type === 'reflection') {
        return 'anonymous';
    }
    else {
        const t = type;
        return t.name || '';
    }
}
function getTypeArguments(type) {
    if (Array.isArray(type.typeArguments)) {
        let typeArgs = [];
        type.typeArguments.forEach(function (typeArg) {
            typeArgs.push(TSHelper.getTypeStr(typeArg));
        });
        return '&lt;' + typeArgs.join(', ') + '&gt;';
    }
    else {
        return '';
    }
}
function getUnionType(type) {
    if (type.type === 'union') {
        if (Array.isArray(type.types)) {
            let unionTypes = [];
            type.types.forEach(function (unionType) {
                unionTypes.push(TSHelper.getTypeStr(unionType));
            });
            return unionTypes.join(' | ');
        }
    }
    return '';
}
function getArrayType(type) {
    if (type.type === 'array') {
        let elementType = TSHelper.getTypeStr(type.elementType);
        if (elementType.indexOf('|') !== -1) {
            // Element type is a union type
            return '(' + elementType + ')[]';
        }
        else {
            return elementType + '[]';
        }
    }
    return '';
}
class TSHelper {
    static getTypeStr(type) {
        let typeStr = '';
        if (type == null)
            return typeStr;
        let typeArguments = getTypeArguments(type);
        if (type.type === 'array') {
            typeStr = getArrayType(type) + typeArguments;
        }
        else if (type.type === 'union') {
            typeStr = getUnionType(type) + typeArguments;
        }
        else {
            typeStr = getType(type) + typeArguments;
        }
        return typeStr;
    }
    static commaSepParams(params) {
        let args = [];
        params = params || undefined;
        if (params && params.length > 0) {
            params.forEach(function (param) {
                if (!param.type)
                    return;
                let arg = '';
                if (param.type.type === 'reflection') {
                    arg = TSHelper.getSignatureForFunction(param);
                }
                else {
                    arg = param.name + ': ' + TSHelper.getTypeStr(param.type);
                }
                args.push(arg);
            });
        }
        return args.join(', ');
    }
    static getSignatureForFunction(param) {
        const paramType = param.type;
        let signatures = paramType.declaration.signatures;
        if (signatures && signatures[0]) {
            return (param.name +
                ': ' +
                '(' +
                TSHelper.commaSepParams(signatures[0].parameters) +
                ') => ' +
                TSHelper.getTypeStr(signatures[0].type));
        }
        else {
            return param.name;
        }
    }
    /**
     * Get flags as a string
     *
     * - Private
     * - Protected
     * - Static
     * - ExportAssignment
     * - Optional
     * - DefaultValue
     * - Rest
     * - Abstract
     * - Let
     * - Const
     *
     * @param {*} flags
     */
    static getFlags(flags) {
        flags = flags || {};
        let names = [];
        for (let f in flags) {
            if (flags[f]) {
                if (f.indexOf('is') === 0) {
                    f = f.substr(2);
                    f = f[0].toLowerCase() + f.substr(1);
                }
                names.push(f);
            }
        }
        return names.join(' ');
    }
    /**
     * Get variable type as Const/Let/Variable
     * @param {*} varNode
     */
    static getVariableType(varNode) {
        let kind = 'var';
        if (varNode.flags) {
            if (varNode.flags.isConst)
                kind = 'const';
            if (varNode.flags.isLet)
                kind = 'let';
        }
        return kind;
    }
    static getVariableStr(varNode) {
        let kind = TSHelper.getVariableType(varNode);
        let type = TSHelper.getTypeStr(varNode.type);
        let defaultVal = varNode.defaultValue;
        let str = kind + ' ' + varNode.name;
        str = type ? str + ': ' + type : str;
        str = defaultVal !== undefined ? str + ' = ' + defaultVal : str;
        return str;
    }
    static shouldDocument(node) {
        if (node && node.shouldDocument === false) {
            return false;
        }
        else {
            return true;
        }
    }
    static getNodeTitle(node) {
        let type = node.kindString;
        const kind = node.kind;
        if (kind === abstract_1.ReflectionKind.Module)
            type = 'Namespace';
        if (kind === abstract_1.ReflectionKind.Enum)
            type = 'Enum';
        if (kind === abstract_1.ReflectionKind.EnumMember)
            type = '';
        if (kind === abstract_1.ReflectionKind.TypeAlias)
            type = 'Type';
        if (kind === abstract_1.ReflectionKind.ObjectLiteral)
            type = 'Object';
        let prefix = '';
        if (kind === abstract_1.ReflectionKind.Method || kind === abstract_1.ReflectionKind.Property) {
            if (node.flags.isStatic) {
                prefix = 'static ';
            }
        }
        if (kind === abstract_1.ReflectionKind.Method ||
            kind === abstract_1.ReflectionKind.Constructor ||
            kind === abstract_1.ReflectionKind.Function)
            return prefix + node.name + '()';
        if (kind === abstract_1.ReflectionKind.Accessor)
            return '>' + node.name;
        if (kind === abstract_1.ReflectionKind.Variable || kind === abstract_1.ReflectionKind.Property)
            return prefix + node.name;
        if (!type)
            return node.name;
        return type + ': ' + node.name;
    }
}
exports.TSHelper = TSHelper;
//# sourceMappingURL=ts-helper.js.map