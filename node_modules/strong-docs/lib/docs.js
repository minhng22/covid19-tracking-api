"use strict";
// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: strong-docs
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const ejs = require("ejs");
const fs = require("fs");
const glob_1 = require("glob");
const path = require("path");
const _ = require("underscore.string");
const doc_1 = require("./doc");
const ts_parser_1 = require("./ts-parser");
const TaskEmitter = require('strong-task-emitter');
const COMMENT_TEMPLATE = path.join(__dirname, '../templates/annotation.ejs');
/**
 * Create a new set of `Docs` with the given `config`.
 *
 * @param {DocsConfig} config
 * @return {Docs}
 */
class Docs {
    constructor(config) {
        this.content = [];
        this.sections = [];
        this.renderedClasses = [];
        // defaults
        config = config || {};
        config.content = config.content || ['*.md'];
        config.extensions = config.extensions || ['.markdown', '.md', '.js', '.ts'];
        if (config.fileSections !== false) {
            config.fileSections = true;
        }
        if (!Array.isArray(config.content)) {
            config.content = [config.content];
        }
        let root = (this.root = config.root || process.cwd());
        this.config = config;
        if (this.config.order) {
            // resolve order paths
            this.config.order = this.config.order.map(function (p) {
                return path.resolve(root, p);
            });
        }
        this.commentTemplate = fs.readFileSync(config.commentTemplate || COMMENT_TEMPLATE, 'utf8');
    }
    /**
     * Parse all content in the given [config](#config) and callback with a `Docs`
     * object.
     *
     * @options  {Object} config
     * @property {String} [title] The title of your documentation site
     * @property {String} [version] The version of the project you are documenting
     * @property {Array}  content Specify your [documentation source files](#documentation-source-files)
     * @property {Number} [codeSectionDepth=4] Specify the depth of [JavaScript sections](#section-depth)
     * @property {String} [assets] Path to your assets directory
     * @end
     * @callback {Function} callback
     * @param {Error} err
     * @param {Docs} docs The `Docs` object
     */
    static parse(config, fn) {
        let docs = new Docs(config);
        docs.parse(function (err) {
            fn(err, err ? undefined : docs);
        });
    }
    static readJSON(file, fn) {
        fs.readFile(file, 'utf8', function (err, str) {
            let isEmptyFile = (err && err.code === 'ENOENT') || str.replace(/\s/g, '') === '';
            let seriousError = err && !isEmptyFile;
            if (seriousError) {
                fn(err);
            }
            else if (isEmptyFile) {
                fn();
            }
            else {
                try {
                    const object = JSON.parse(str);
                    fn(null, object);
                }
                catch (e) {
                    return fn(e);
                }
            }
        });
    }
    /**
     * Read the config and package at paths in the given options.
     *
     * @options {Object} options
     * @prop {String} [configPath] The path (relative to cwd) to docs.json
     * @prop {String} [packagePath] The path (relative to cwd) to package.json
     * @end
     * @callback {Function} callback
     * @param {Error} err An error if one occurred loading either the docs.json or package.json
     * @param {Object} config The config object loaded from `options.configPath`
     */
    static readConfig(options, fn) {
        options = options || {};
        let configPath = options.configPath || 'docs.json';
        let packagePath = options.packagePath || 'package.json';
        Docs.readJSON(configPath, function (err, config) {
            if (err) {
                err.message = 'Could not load config data: ' + err.message;
                fn(err);
            }
            else {
                // default config
                config = config || {};
                Docs.readJSON(packagePath, function (err2, pkg) {
                    if (err2) {
                        err2.message = 'Could not load package data: ' + err2.message;
                        fn(err2);
                    }
                    else {
                        pkg = pkg || undefined;
                        config.package = pkg;
                        fn(null, config);
                    }
                });
            }
        });
    }
    static findFiles(root, f) {
        let files = glob_1.sync(f, { cwd: root, nonull: false });
        return files;
    }
    parse(fn) {
        let self = this;
        let content = this.config.content;
        let init = this.config.init;
        let root = this.root;
        let cwd = process.cwd();
        let te = new TaskEmitter();
        let files = {};
        let matchedFiles = [];
        let tsFiles = [];
        // reference to individual classes
        this.classes = {};
        te.on('error', fn);
        te.on('done', () => {
            matchedFiles.forEach((f) => {
                let contents;
                if (typeof f === 'object') {
                    contents = Docs.fauxSectionToMarkdown(f);
                    let fauxdoc = new doc_1.Doc('faux-section.md', contents, false, this);
                    this.content.push(fauxdoc);
                }
                else {
                    f = path.resolve(root, f);
                    if (path.extname(f) === '.ts') {
                        // Filter out ts files, and process them as a bunch
                        tsFiles.push(f);
                        return;
                    }
                    contents = files[f];
                    if (this.hasExt(f)) {
                        let doc = new doc_1.Doc(f, contents, path.extname(f) === '.js', self);
                        doc.classes.forEach(function (c) {
                            if (!(c.classDesc in self.classes)) {
                                self.classes[c.classDesc] = doc;
                            }
                        });
                        self.content.push(doc);
                    }
                }
            });
            // Process ts files
            if (tsFiles.length > 0) {
                let tsParser = new ts_parser_1.TSParser(tsFiles, this.config.typedoc);
                let parsedData = tsParser.parse();
                let doc = {
                    classes: parsedData.constructs,
                    sections: parsedData.sections,
                    html: '',
                };
                doc.classes.forEach(function (tsConstruct) {
                    doc.html += tsConstruct.render();
                });
                self.content.push(doc);
            }
            this.buildSections();
            fn();
        });
        te.on('readdir', (f, dir) => {
            dir.forEach(function (df) {
                te.task(fs, 'stat', path.join(f, df));
            });
        });
        te.on('stat', (f, stat) => {
            if (stat.isDirectory()) {
                te.task(fs, 'readdir', f);
            }
            else {
                te.task(fs, 'readFile', f, 'utf8');
            }
        });
        te.on('readFile', (f, enc, contents) => {
            files[f] = contents;
        });
        te.on('init', () => {
            content.forEach((p) => {
                if (typeof p === 'string') {
                    let matched = Docs.findFiles(root || cwd, p);
                    matched.forEach(function (f) {
                        if (matchedFiles.indexOf(f) === -1) {
                            matchedFiles.push(f);
                        }
                    });
                }
                else {
                    matchedFiles.push(p);
                }
            });
            matchedFiles.forEach((p) => {
                if (typeof p === 'string') {
                    let f = path.join(root || cwd, p);
                    if (self.hasExt(f)) {
                        te.task(fs, 'readFile', f, 'utf8');
                    }
                    else {
                        te.task(fs, 'stat', f);
                    }
                }
            });
            if (!te.remaining()) {
                te.emit('error', new Error('no matching files were found'));
            }
        });
        if (init) {
            te.task('init', (cb) => {
                let opts = {
                    cwd: root || process.cwd(),
                    timeout: 2000 /* milliseconds */,
                };
                child_process_1.exec(init, opts, cb);
            });
        }
        else {
            te.emit('init');
        }
    }
    hasExt(f) {
        return ~this.config.extensions.indexOf(path.extname(f));
    }
    buildSections() {
        let sections = this.sections;
        let order = this.config.order;
        let files = this.content;
        let content = this.content;
        let root = this.root;
        // order content using index
        if (Array.isArray(order)) {
            files = content.sort((a, b) => {
                let pathA = path.resolve(root, a.file);
                let pathB = path.resolve(root, b.file);
                let indexA = order.indexOf(pathA);
                let indexB = order.indexOf(pathB);
                if (indexA === indexB)
                    return 0;
                return indexA > indexB ? 1 : -1;
            });
        }
        for (const f of files) {
            f.sections.forEach((s) => {
                sections.push(s);
            });
        }
    }
    getUrlSafeAnchor(title) {
        return _.slugify(title.toLowerCase().replace(/\./g, '-'));
    }
    getUniqueAnchor(title) {
        let anchors = (this.anchors = this.anchors || {});
        let anchor;
        let urlSafe = this.getUrlSafeAnchor(title);
        let isUsed = anchors[urlSafe];
        if (!urlSafe) {
            return '';
        }
        if (isUsed) {
            let split = urlSafe.split('');
            let lastCharIndex = split.length - 1;
            let lastChar = split[lastCharIndex];
            let num = parseInt(lastChar);
            let isNum = !isNaN(num);
            if (isNum) {
                split[lastCharIndex] = (num + 1).toString();
            }
            else {
                split.push('-1');
            }
            anchor = this.getUniqueAnchor(split.join(''));
        }
        else {
            anchor = urlSafe;
        }
        // index anchor
        anchors[anchor] = true;
        return anchor;
    }
    /**
     * Render the given [config](#config) as html.
     *
     * @param {Object} config
     * @param {Function} callback
     */
    static toHtml(config, fn) {
        let template = config.template || path.join(__dirname, '..', 'templates', 'docs.ejs');
        Docs.parse(config, function (err, docs) {
            if (err) {
                return fn(err);
            }
            ejs.renderFile(template, { docs: docs }, function (err2, html) {
                if (err2) {
                    fn(err2);
                }
                else {
                    docs.postProcessHtml(html, fn);
                }
            });
        });
    }
    static fauxSectionToMarkdown(section) {
        let md = '';
        const n = section.depth;
        for (let i = 0; i < n; i++) {
            md += '#';
        }
        md += ' ' + section.title;
        return md;
    }
    /**
     * A hook to do any post-processing of the HTML before `toHtml` signals its
     * completion.
     *
     * @param  {String}   html     The fleshed-out HTML.
     * @param  {Function} callback A Node-style callback.
     * @return {Docs}              The Docs instance, for cascading.
     */
    postProcessHtml(html, callback) {
        let pkg = this.config.package;
        let version = pkg && pkg.version;
        if (version) {
            callback(null, addVersion(html));
        }
        else {
            callback(null, html);
        }
        return this;
        // We want to add and de-emphasize the version number within the content's
        // main title.
        function addVersion(htmlStr) {
            // This is the poor man's version of $('h1').get(0).html(...)
            // TODO(schoon) - Add DOM-aware post-processing capabilities, i.e. jsdom.
            return htmlStr.replace('</h1>', ' <small>v' + version + '</small></h1>');
        }
    }
    getAllMarkdown() {
        return this.content
            .filter(doc => {
            return !doc.isJS;
        })
            .sort(alpha);
    }
    getMarkdownSections() {
        let sections = [];
        this.getAllMarkdown().forEach((doc) => {
            sections = sections.concat(doc.sections);
        });
        return sections;
    }
    getAllModules() {
        return this.content
            .filter(function (doc) {
            return doc.isJS;
        })
            .sort(alpha);
    }
}
exports.Docs = Docs;
function alpha(a, b) {
    const x = a.file || '';
    const y = b.file || '';
    return x.localeCompare(y);
}
//# sourceMappingURL=docs.js.map