import { Doc } from './doc';
import { AnyObject, Options, Section } from './ts-helper';
import { TSConstruct } from './ts-construct';
export declare type Callback<T = any> = (err?: Error | null | undefined, result?: T) => void;
export interface ContentTitle {
    title: string;
    depth: number;
}
export interface DocsConfig {
    content: (string | ContentTitle)[];
    codeSectionDepth?: number;
    assets?: string | {
        [key: string]: string;
    };
    extensions: string[];
    order?: string[];
    fileSections?: boolean;
    package?: AnyObject;
    typedoc?: Options;
    template?: string;
    commentTemplate?: string;
    init?: string;
    root?: string;
}
export interface TSDoc {
    classes: TSConstruct[];
    sections: Section[];
    html: string;
    isJS?: boolean;
    file?: string;
}
/**
 * Create a new set of `Docs` with the given `config`.
 *
 * @param {DocsConfig} config
 * @return {Docs}
 */
export declare class Docs {
    root: string;
    config: DocsConfig;
    content: (Doc | TSDoc)[];
    sections: Section[];
    renderedClasses: string[];
    commentTemplate: string;
    anchors: AnyObject;
    classes: AnyObject;
    constructor(config: DocsConfig);
    /**
     * Parse all content in the given [config](#config) and callback with a `Docs`
     * object.
     *
     * @options  {Object} config
     * @property {String} [title] The title of your documentation site
     * @property {String} [version] The version of the project you are documenting
     * @property {Array}  content Specify your [documentation source files](#documentation-source-files)
     * @property {Number} [codeSectionDepth=4] Specify the depth of [JavaScript sections](#section-depth)
     * @property {String} [assets] Path to your assets directory
     * @end
     * @callback {Function} callback
     * @param {Error} err
     * @param {Docs} docs The `Docs` object
     */
    static parse(config: DocsConfig, fn: Callback<Docs>): void;
    static readJSON(file: string, fn: Callback<AnyObject>): void;
    /**
     * Read the config and package at paths in the given options.
     *
     * @options {Object} options
     * @prop {String} [configPath] The path (relative to cwd) to docs.json
     * @prop {String} [packagePath] The path (relative to cwd) to package.json
     * @end
     * @callback {Function} callback
     * @param {Error} err An error if one occurred loading either the docs.json or package.json
     * @param {Object} config The config object loaded from `options.configPath`
     */
    static readConfig(options: Options, fn: Callback<DocsConfig>): void;
    private static findFiles;
    parse(fn: Function): void;
    hasExt(f: string): number;
    buildSections(): void;
    getUrlSafeAnchor(title: string): string;
    getUniqueAnchor(title: string): string;
    /**
     * Render the given [config](#config) as html.
     *
     * @param {Object} config
     * @param {Function} callback
     */
    static toHtml(config: DocsConfig, fn: Callback<string>): void;
    private static fauxSectionToMarkdown;
    /**
     * A hook to do any post-processing of the HTML before `toHtml` signals its
     * completion.
     *
     * @param  {String}   html     The fleshed-out HTML.
     * @param  {Function} callback A Node-style callback.
     * @return {Docs}              The Docs instance, for cascading.
     */
    postProcessHtml(html: string, callback: Callback<string>): this;
    getAllMarkdown(): (TSDoc | Doc)[];
    getMarkdownSections(): Section[];
    getAllModules(): (TSDoc | Doc)[];
}
