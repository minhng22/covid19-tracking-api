"use strict";
// Copyright IBM Corp. 2018,2019. All Rights Reserved.
// Node module: strong-docs
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const marked = require("marked");
const typedoc_1 = require("typedoc");
const ts_construct_1 = require("./ts-construct");
const ts_helper_1 = require("./ts-helper");
marked.setOptions({
    highlight: function (code) {
        return require('highlight.js').highlightAuto(code).value;
    },
});
class TSParser {
    constructor(filePaths, config) {
        this.sections = [];
        this.constructs = [];
        this.filePaths = filePaths;
        config = config || {};
        let options = {
            mode: 'modules',
            logger: 'console',
            module: 'commonjs',
            experimentalDecorators: true,
            includeDeclarations: true,
            // Set excludeExternals to `true` to exclude `node_modules/*`.
            // Please note it's very time-consuming to parse external/declaration files
            excludeExternals: true,
            // https://github.com/TypeStrong/typedoc/pull/694
            excludeNotExported: false,
            excludeProtected: true,
            excludePrivate: true,
        };
        if (!config.tsconfig) {
            // Set up the default target only if `tsconfig` is not present
            options.target = 'es6';
        }
        for (let i in config) {
            if (config[i] !== undefined) {
                options[i] = config[i];
            }
        }
        this.app = new typedoc_1.Application(options);
    }
    // Override typedoc.Application.convert() to get errors
    static convert(app, src) {
        app.logger.writeln('Using TypeScript %s from %s', app.getTypeScriptVersion(), app.getTypeScriptPath());
        let result = app.converter.convert(src);
        if (result.errors && result.errors.length) {
            app.logger.diagnostics(result.errors);
            if (app.ignoreCompilerErrors) {
                app.logger.resetErrors();
            }
        }
        return result;
    }
    parse() {
        let result = TSParser.convert(this.app, this.filePaths);
        let project = result.project;
        if (result.errors && result.errors.length) {
            this.app.logger.error('TypeScript compilation fails. See error messages in the log above.');
        }
        else {
            // Replace usage of deprecated `project.toObject()`, which is broken with typedoc@0.10.0.
            let projectObject = this.app.serializer.projectToObject(project);
            let exportedConstructs = this.findExportedConstructs(projectObject, this.filePaths);
            exportedConstructs.forEach((node) => {
                if (node.kind === typedoc_1.ReflectionKind.Class ||
                    node.kind === typedoc_1.ReflectionKind.Interface ||
                    node.kind === typedoc_1.ReflectionKind.Function ||
                    node.kind === typedoc_1.ReflectionKind.ObjectLiteral ||
                    node.kind === typedoc_1.ReflectionKind.Module ||
                    node.kind === typedoc_1.ReflectionKind.Variable ||
                    node.kind === typedoc_1.ReflectionKind.Enum ||
                    node.kind === typedoc_1.ReflectionKind.TypeAlias) {
                    processMarkdown(node);
                    this.constructs.push(new ts_construct_1.TSConstruct(node));
                    createAnchor(node);
                    let title = ts_helper_1.TSHelper.getNodeTitle(node);
                    this.sections.push({
                        title: title,
                        anchor: node.anchorId,
                        depth: 3,
                    });
                    // build sections for children
                    let children = node.children;
                    if ((node.kind === typedoc_1.ReflectionKind.Class ||
                        node.kind === typedoc_1.ReflectionKind.Interface ||
                        node.kind === typedoc_1.ReflectionKind.ObjectLiteral ||
                        node.kind === typedoc_1.ReflectionKind.Module ||
                        node.kind === typedoc_1.ReflectionKind.Enum) &&
                        children &&
                        children.length > 0) {
                        children.forEach((child) => {
                            if (child.inheritedFrom ||
                                child.flags.isPrivate ||
                                child.flags.isProtected) {
                                child.shouldDocument = false;
                            }
                            else {
                                // This is needed in UI, good to keep the eligibility logic at one place
                                child.shouldDocument = true;
                                processMarkdown(child);
                                child.parent = node;
                                createAnchor(child);
                                this.sections.push({
                                    title: ts_helper_1.TSHelper.getNodeTitle(child),
                                    anchor: child.anchorId,
                                    depth: 4,
                                });
                            }
                        });
                    }
                }
            });
        }
        return {
            sections: this.sections,
            constructs: this.constructs,
            errors: result.errors,
        };
    }
    findExportedConstructs(construct, filePaths) {
        let exportedConstructs = [];
        function findConstructs(node, files, parent) {
            if (parent) {
                node.parent = parent;
            }
            // Global = 0, ExternalModule = 1
            if (node.kind === typedoc_1.ReflectionKind.Global ||
                node.kind === typedoc_1.ReflectionKind.ExternalModule) {
                let children = node.children;
                if (children && children.length > 0) {
                    children.forEach(function (child) {
                        findConstructs(child, files, node);
                    });
                }
            }
            else {
                if ((node.kind === typedoc_1.ReflectionKind.Class ||
                    node.kind === typedoc_1.ReflectionKind.Interface ||
                    node.kind === typedoc_1.ReflectionKind.TypeAlias ||
                    node.kind === typedoc_1.ReflectionKind.ObjectLiteral ||
                    node.kind === typedoc_1.ReflectionKind.Module ||
                    node.kind === typedoc_1.ReflectionKind.Variable ||
                    node.kind === typedoc_1.ReflectionKind.Enum ||
                    node.kind === typedoc_1.ReflectionKind.Function) &&
                    node.flags.isExported &&
                    files.find(filePath => node.sources != null &&
                        node.sources[0].fileName.split('/').pop() ===
                            filePath.split('/').pop())) {
                    if (parent && parent.kind === typedoc_1.ReflectionKind.Module) {
                        // Set the node name with its parent namespace
                        node.name = parent ? parent.name + '.' + node.name : node.name;
                    }
                    exportedConstructs.push(node);
                }
            }
        }
        findConstructs(construct, filePaths);
        return exportedConstructs;
    }
}
exports.TSParser = TSParser;
function getQualifiedName(node) {
    const names = [];
    let current = node;
    while (current) {
        if (current.kind === typedoc_1.ReflectionKind.Global ||
            current.kind === typedoc_1.ReflectionKind.ExternalModule) {
            // Skip global/external module nodes
            break;
        }
        const index = current.name.lastIndexOf('.');
        const name = index === -1 ? current.name : current.name.substring(index + 1);
        // Check static methods/properties
        if (current.kind === typedoc_1.ReflectionKind.Method ||
            current.kind === typedoc_1.ReflectionKind.Property) {
            if (current.flags.isStatic) {
                names.unshift(name);
            }
            else {
                names.unshift(`prototype.${name}`);
            }
        }
        else {
            names.unshift(name);
        }
        current = current.parent;
    }
    const qname = names.join('.');
    return qname;
}
function createAnchor(node) {
    node.anchorId = getQualifiedName(node);
}
function processMarkdown(node) {
    function markComment(comment) {
        if (comment.shortText) {
            comment.shortText = marked(comment.shortText);
        }
        if (comment.text) {
            comment.text = marked(comment.text);
        }
        if (comment.returns) {
            comment.returns = marked(comment.returns);
        }
    }
    function mark(tsNode) {
        if (tsNode.comment) {
            markComment(tsNode.comment);
        }
        if (tsNode.signatures) {
            tsNode.signatures.forEach(signature => {
                if (signature.comment) {
                    markComment(signature.comment);
                }
            });
        }
        let children = tsNode.children || (tsNode.signatures && tsNode.signatures[0].parameters);
        if (children && children.length > 0) {
            children.forEach((child) => {
                mark(child);
            });
        }
    }
    mark(node);
}
//# sourceMappingURL=ts-parser.js.map