"use strict";
// Copyright IBM Corp. 2019. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const keys_1 = require("./keys");
/**
 * Decorate a class as a named extension point. If the decoration is not
 * present, the name of the class will be used.
 *
 * @example
 * ```ts
 * import {extensionPoint} from '@loopback/core';
 *
 * @extensionPoint(GREETER_EXTENSION_POINT_NAME)
 * export class GreetingService {
 *   // ...
 * }
 * ```
 *
 * @param name - Name of the extension point
 */
function extensionPoint(name, ...specs) {
    return context_1.bind({ tags: { [keys_1.CoreTags.EXTENSION_POINT]: name } }, ...specs);
}
exports.extensionPoint = extensionPoint;
/**
 * Shortcut to inject extensions for the given extension point.
 *
 * @example
 * ```ts
 * import {Getter} from '@loopback/context';
 * import {extensionPoint, extensions} from '@loopback/core';
 *
 * @extensionPoint(GREETER_EXTENSION_POINT_NAME)
 * export class GreetingService {
 *  constructor(
 *    @extensions() // Inject extensions for the extension point
 *    private getGreeters: Getter<Greeter[]>,
 *    // ...
 * ) {
 *   // ...
 * }
 * ```
 *
 * @param extensionPointName - Name of the extension point. If not supplied, we
 * use the `name` tag from the extension point binding or the class name of the
 * extension point class. If a class needs to inject extensions from multiple
 * extension points, use different `extensionPointName` for different types of
 * extensions.
 */
function extensions(extensionPointName) {
    return context_1.inject('', { decorator: '@extensions' }, (ctx, injection, session) => {
        extensionPointName = (extensionPointName !== null && extensionPointName !== void 0 ? extensionPointName : inferExtensionPointName(injection.target, session.currentBinding));
        const bindingFilter = extensionFilter(extensionPointName);
        return context_1.createViewGetter(ctx, bindingFilter, injection.metadata.bindingComparator, session);
    });
}
exports.extensions = extensions;
/**
 * Infer the extension point name from binding tags/class name
 * @param injectionTarget - Target class or prototype
 * @param currentBinding - Current binding
 */
function inferExtensionPointName(injectionTarget, currentBinding) {
    if (currentBinding) {
        const name = currentBinding.tagMap[keys_1.CoreTags.EXTENSION_POINT] ||
            currentBinding.tagMap[context_1.ContextTags.NAME];
        if (name)
            return name;
    }
    let target;
    if (typeof injectionTarget === 'function') {
        // Constructor injection
        target = injectionTarget;
    }
    else {
        // Injection on the prototype
        target = injectionTarget.constructor;
    }
    return target.name;
}
/**
 * A factory function to create binding filter for extensions of a named
 * extension point
 * @param extensionPointName - Name of the extension point
 */
function extensionFilter(extensionPointName) {
    return context_1.filterByTag({
        [keys_1.CoreTags.EXTENSION_FOR]: extensionPointName,
    });
}
exports.extensionFilter = extensionFilter;
/**
 * A factory function to create binding template for extensions of the given
 * extension point
 * @param extensionPointName - Name of the extension point
 */
function extensionFor(extensionPointName) {
    return binding => binding.tag({ [keys_1.CoreTags.EXTENSION_FOR]: extensionPointName });
}
exports.extensionFor = extensionFor;
/**
 * Register an extension for the given extension point to the context
 * @param context - Context object
 * @param extensionPointName - Name of the extension point
 * @param extensionClass - Class or a provider for an extension
 * @param options - Options Options for the creation of binding from class
 */
function addExtension(context, extensionPointName, extensionClass, options) {
    const binding = context_1.createBindingFromClass(extensionClass, options).apply(extensionFor(extensionPointName));
    context.add(binding);
    return binding;
}
exports.addExtension = addExtension;
//# sourceMappingURL=extension-point.js.map