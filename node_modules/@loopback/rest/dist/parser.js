"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const openapi_v3_1 = require("@loopback/openapi-v3");
const debug_1 = __importDefault(require("debug"));
const body_parsers_1 = require("./body-parsers");
const coerce_parameter_1 = require("./coercion/coerce-parameter");
const rest_http_error_1 = require("./rest-http-error");
const request_body_validator_1 = require("./validation/request-body.validator");
const debug = debug_1.default('loopback:rest:parser');
/**
 * Parses the request to derive arguments to be passed in for the Application
 * controller method
 *
 * @param request - Incoming HTTP request
 * @param route - Resolved Route
 */
async function parseOperationArgs(request, route, requestBodyParser = new body_parsers_1.RequestBodyParser(), options = {}) {
    debug('Parsing operation arguments for route %s', route.describe());
    const operationSpec = route.spec;
    const pathParams = route.pathParams;
    const body = await requestBodyParser.loadRequestBodyIfNeeded(operationSpec, request);
    return buildOperationArguments(operationSpec, request, pathParams, body, route.schemas, options);
}
exports.parseOperationArgs = parseOperationArgs;
function buildOperationArguments(operationSpec, request, pathParams, body, globalSchemas, options = {}) {
    var _a;
    let requestBodyIndex = -1;
    if (operationSpec.requestBody) {
        // the type of `operationSpec.requestBody` could be `RequestBodyObject`
        // or `ReferenceObject`, resolving a `$ref` value is not supported yet.
        if (openapi_v3_1.isReferenceObject(operationSpec.requestBody)) {
            throw new Error('$ref requestBody is not supported yet.');
        }
        const i = operationSpec.requestBody[openapi_v3_1.REQUEST_BODY_INDEX];
        requestBodyIndex = i ? i : 0;
    }
    const paramArgs = [];
    for (const paramSpec of (_a = operationSpec.parameters, (_a !== null && _a !== void 0 ? _a : []))) {
        if (openapi_v3_1.isReferenceObject(paramSpec)) {
            // TODO(bajtos) implement $ref parameters
            // See https://github.com/strongloop/loopback-next/issues/435
            throw new Error('$ref parameters are not supported yet.');
        }
        const spec = paramSpec;
        const rawValue = getParamFromRequest(spec, request, pathParams);
        const coercedValue = coerce_parameter_1.coerceParameter(rawValue, spec);
        paramArgs.push(coercedValue);
    }
    debug('Validating request body - value %j', body);
    request_body_validator_1.validateRequestBody(body, operationSpec.requestBody, globalSchemas, options);
    if (requestBodyIndex > -1)
        paramArgs.splice(requestBodyIndex, 0, body.value);
    return paramArgs;
}
function getParamFromRequest(spec, request, pathParams) {
    switch (spec.in) {
        case 'query':
            return request.query[spec.name];
        case 'path':
            return pathParams[spec.name];
        case 'header':
            // @jannyhou TBD: check edge cases
            return request.headers[spec.name.toLowerCase()];
        // TODO(jannyhou) to support `cookie`,
        // see issue https://github.com/strongloop/loopback-next/issues/997
        default:
            throw rest_http_error_1.RestHttpErrors.invalidParamLocation(spec.in);
    }
}
//# sourceMappingURL=parser.js.map