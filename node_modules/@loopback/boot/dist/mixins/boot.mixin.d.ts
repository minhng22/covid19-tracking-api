import { Binding, Constructor, Context } from '@loopback/context';
import { Booter, BootOptions } from '../types';
export { Binding };
/**
 * Mixin for @loopback/boot. This Mixin provides the following:
 * - Implements the Bootable Interface as follows.
 * - Add a `projectRoot` property to the Class
 * - Adds an optional `bootOptions` property to the Class that can be used to
 *    store the Booter conventions.
 * - Adds the `BootComponent` to the Class (which binds the Bootstrapper and default Booters)
 * - Provides the `boot()` convenience method to call Bootstrapper.boot()
 * - Provides the `booter()` convenience method to bind a Booter(s) to the Application
 * - Override `component()` to call `mountComponentBooters`
 * - Adds `mountComponentBooters` which binds Booters to the application from `component.booters[]`
 *
 * ******************** NOTE ********************
 * Trying to constrain the type of this Mixin (or any Mixin) will cause errors.
 * For example, constraining this Mixin to type Application require all types using by
 * Application to be imported (including it's dependencies such as ResolutionSession).
 * Another issue was that if a Mixin that is type constrained is used with another Mixin
 * that is not, it will result in an error.
 * Example (class MyApp extends BootMixin(RepositoryMixin(Application))) {};
 ********************* END OF NOTE ********************
 */
export declare function BootMixin<T extends Constructor<any>>(superClass: T): {
    new (...args: any[]): {
        [x: string]: any;
        projectRoot: string;
        bootOptions?: BootOptions | undefined;
        /**
         * Convenience method to call bootstrapper.boot() by resolving bootstrapper
         */
        boot(): Promise<void>;
        /**
         * Given a N number of Booter Classes, this method binds them using the
         * prefix and tag expected by the Bootstrapper.
         *
         * @param booterCls - Booter classes to bind to the Application
         *
         * @example
         * ```ts
         * app.booters(MyBooter, MyOtherBooter)
         * ```
         */
        booters(...booterCls: Constructor<Booter>[]): Binding<any>[];
        /**
         * Override to ensure any Booter's on a Component are also mounted.
         *
         * @param component - The component to add.
         *
         * @example
         * ```ts
         *
         * export class ProductComponent {
         *   booters = [ControllerBooter, RepositoryBooter];
         *   providers = {
         *     [AUTHENTICATION_STRATEGY]: AuthStrategy,
         *     [AUTHORIZATION_ROLE]: Role,
         *   };
         * };
         *
         * app.component(ProductComponent);
         * ```
         */
        component(component: Constructor<{}>): void;
        /**
         * Get an instance of a component and mount all it's
         * booters. This function is intended to be used internally
         * by component()
         *
         * @param component - The component to mount booters of
         */
        mountComponentBooters(component: Constructor<{}>): void;
    };
} & T;
/**
 * Method which binds a given Booter to a given Context with the Prefix and
 * Tags expected by the Bootstrapper
 *
 * @param ctx - The Context to bind the Booter Class
 * @param booterCls - Booter class to be bound
 */
export declare function _bindBooter(ctx: Context, booterCls: Constructor<Booter>): Binding;
