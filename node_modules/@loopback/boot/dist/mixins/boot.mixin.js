"use strict";
// Copyright IBM Corp. 2018,2019. All Rights Reserved.
// Node module: @loopback/boot
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
exports.Binding = context_1.Binding;
const boot_component_1 = require("../boot.component");
const keys_1 = require("../keys");
/**
 * Mixin for @loopback/boot. This Mixin provides the following:
 * - Implements the Bootable Interface as follows.
 * - Add a `projectRoot` property to the Class
 * - Adds an optional `bootOptions` property to the Class that can be used to
 *    store the Booter conventions.
 * - Adds the `BootComponent` to the Class (which binds the Bootstrapper and default Booters)
 * - Provides the `boot()` convenience method to call Bootstrapper.boot()
 * - Provides the `booter()` convenience method to bind a Booter(s) to the Application
 * - Override `component()` to call `mountComponentBooters`
 * - Adds `mountComponentBooters` which binds Booters to the application from `component.booters[]`
 *
 * ******************** NOTE ********************
 * Trying to constrain the type of this Mixin (or any Mixin) will cause errors.
 * For example, constraining this Mixin to type Application require all types using by
 * Application to be imported (including it's dependencies such as ResolutionSession).
 * Another issue was that if a Mixin that is type constrained is used with another Mixin
 * that is not, it will result in an error.
 * Example (class MyApp extends BootMixin(RepositoryMixin(Application))) {};
 ********************* END OF NOTE ********************
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function BootMixin(superClass) {
    return class extends superClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args) {
            super(...args);
            this.component(boot_component_1.BootComponent);
            // We Dynamically bind the Project Root and Boot Options so these values can
            // be used to resolve an instance of the Bootstrapper (as they are dependencies)
            this.bind(keys_1.BootBindings.PROJECT_ROOT).toDynamicValue(() => this.projectRoot);
            this.bind(keys_1.BootBindings.BOOT_OPTIONS).toDynamicValue(() => this.bootOptions);
        }
        /**
         * Convenience method to call bootstrapper.boot() by resolving bootstrapper
         */
        async boot() {
            if (this.state === 'booting')
                return this.awaitState('booted');
            this.assertNotInProcess('boot');
            this.assertInStates('boot', 'created', 'booted');
            if (this.state === 'booted')
                return;
            this.setState('booting');
            // Get a instance of the BootStrapper
            const bootstrapper = await this.get(keys_1.BootBindings.BOOTSTRAPPER_KEY);
            await bootstrapper.boot();
            this.setState('booted');
        }
        /**
         * Given a N number of Booter Classes, this method binds them using the
         * prefix and tag expected by the Bootstrapper.
         *
         * @param booterCls - Booter classes to bind to the Application
         *
         * @example
         * ```ts
         * app.booters(MyBooter, MyOtherBooter)
         * ```
         */
        booters(...booterCls) {
            return booterCls.map(cls => _bindBooter(this, cls));
        }
        /**
         * Override to ensure any Booter's on a Component are also mounted.
         *
         * @param component - The component to add.
         *
         * @example
         * ```ts
         *
         * export class ProductComponent {
         *   booters = [ControllerBooter, RepositoryBooter];
         *   providers = {
         *     [AUTHENTICATION_STRATEGY]: AuthStrategy,
         *     [AUTHORIZATION_ROLE]: Role,
         *   };
         * };
         *
         * app.component(ProductComponent);
         * ```
         */
        component(component) {
            super.component(component);
            this.mountComponentBooters(component);
        }
        /**
         * Get an instance of a component and mount all it's
         * booters. This function is intended to be used internally
         * by component()
         *
         * @param component - The component to mount booters of
         */
        mountComponentBooters(component) {
            const componentKey = `components.${component.name}`;
            const compInstance = this.getSync(componentKey);
            if (compInstance.booters) {
                this.booters(...compInstance.booters);
            }
        }
    };
}
exports.BootMixin = BootMixin;
/**
 * Method which binds a given Booter to a given Context with the Prefix and
 * Tags expected by the Bootstrapper
 *
 * @param ctx - The Context to bind the Booter Class
 * @param booterCls - Booter class to be bound
 */
function _bindBooter(ctx, booterCls) {
    const binding = context_1.createBindingFromClass(booterCls, {
        namespace: keys_1.BootBindings.BOOTER_PREFIX,
        defaultScope: context_1.BindingScope.SINGLETON,
    }).tag(keys_1.BootTags.BOOTER);
    ctx.add(binding);
    /**
     * Set up configuration binding as alias to `BootBindings.BOOT_OPTIONS`
     * so that the booter can use `@config`.
     */
    if (binding.tagMap.artifactNamespace) {
        ctx
            .configure(binding.key)
            .toAlias(`${keys_1.BootBindings.BOOT_OPTIONS.key}#${binding.tagMap.artifactNamespace}`);
    }
    return binding;
}
exports._bindBooter = _bindBooter;
//# sourceMappingURL=boot.mixin.js.map