"use strict";
// Copyright IBM Corp. 2017,2019. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const uuid_1 = require("uuid");
const binding_1 = require("./binding");
const binding_config_1 = require("./binding-config");
const binding_filter_1 = require("./binding-filter");
const binding_key_1 = require("./binding-key");
const context_view_1 = require("./context-view");
const keys_1 = require("./keys");
const resolution_session_1 = require("./resolution-session");
const value_promise_1 = require("./value-promise");
/**
 * Polyfill Symbol.asyncIterator as required by TypeScript for Node 8.x.
 * See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html
 */
if (!Symbol.asyncIterator) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Symbol.asyncIterator = Symbol.for('Symbol.asyncIterator');
}
/**
 * WARNING: This following import must happen after the polyfill. The
 * `auto-import` by an IDE such as VSCode may move the import before the
 * polyfill. It must be then fixed manually.
 */
const p_event_1 = require("p-event");
const debug = debug_1.default('loopback:context');
/**
 * Context provides an implementation of Inversion of Control (IoC) container
 */
class Context extends events_1.EventEmitter {
    /**
     * Create a new context.
     *
     * @example
     * ```ts
     * // Create a new root context, let the framework to create a unique name
     * const rootCtx = new Context();
     *
     * // Create a new child context inheriting bindings from `rootCtx`
     * const childCtx = new Context(rootCtx);
     *
     * // Create another root context called "application"
     * const appCtx = new Context('application');
     *
     * // Create a new child context called "request" and inheriting bindings
     * // from `appCtx`
     * const reqCtx = new Context(appCtx, 'request');
     * ```
     * @param _parent - The optional parent context
     * @param name - Name of the context, if not provided, a `uuid` will be
     * generated as the name
     */
    constructor(_parent, name) {
        super();
        /**
         * Key to binding map as the internal registry
         */
        this.registry = new Map();
        /**
         * Internal counter for pending notification events which are yet to be
         * processed by observers.
         */
        this.pendingNotifications = 0;
        if (typeof _parent === 'string') {
            name = _parent;
            _parent = undefined;
        }
        this._parent = _parent;
        this.name = (name !== null && name !== void 0 ? name : uuid_1.v1());
    }
    /**
     * Wrap the debug statement so that it always print out the context name
     * as the prefix
     * @param args - Arguments for the debug
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _debug(...args) {
        /* istanbul ignore if */
        if (!debug.enabled)
            return;
        const formatter = args.shift();
        if (typeof formatter === 'string') {
            debug(`[%s] ${formatter}`, this.name, ...args);
        }
        else {
            debug('[%s] ', this.name, formatter, ...args);
        }
    }
    /**
     * Set up an internal listener to notify registered observers asynchronously
     * upon `bind` and `unbind` events. This method will be called lazily when
     * the first observer is added.
     */
    setupEventHandlersIfNeeded() {
        if (this.notificationQueue != null)
            return;
        this.addParentEventListener('bind');
        this.addParentEventListener('unbind');
        // The following are two async functions. Returned promises are ignored as
        // they are long-running background tasks.
        this.startNotificationTask().catch(err => {
            this.handleNotificationError(err);
        });
        let ctx = this._parent;
        while (ctx) {
            ctx.setupEventHandlersIfNeeded();
            ctx = ctx._parent;
        }
    }
    /**
     * Add an event listener to its parent context so that this context will
     * be notified of parent events, such as `bind` or `unbind`.
     * @param event - Event name
     */
    addParentEventListener(event) {
        var _a;
        if (this._parent == null)
            return;
        // Keep track of parent event listeners so that we can remove them
        this._parentEventListeners = (_a = this._parentEventListeners, (_a !== null && _a !== void 0 ? _a : new Map()));
        if (this._parentEventListeners.has(event))
            return;
        const parentEventListener = (binding, context) => {
            // Propagate the event to this context only if the binding key does not
            // exist in this context. The parent binding is shadowed if there is a
            // binding with the same key in this one.
            if (this.contains(binding.key)) {
                this._debug('Event %s %s is not re-emitted from %s to %s', event, binding.key, context.name, this.name);
                return;
            }
            this._debug('Re-emitting %s %s from %s to %s', event, binding.key, context.name, this.name);
            this.emit(event, binding, context);
        };
        this._parentEventListeners.set(event, parentEventListener);
        // Listen on the parent context events
        this._parent.on(event, parentEventListener);
    }
    /**
     * Handle errors caught during the notification of observers
     * @param err - Error
     */
    handleNotificationError(err) {
        // Bubbling up the error event over the context chain
        // until we find an error listener
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let ctx = this;
        while (ctx) {
            if (ctx.listenerCount('error') === 0) {
                // No error listener found, try its parent
                ctx = ctx._parent;
                continue;
            }
            this._debug('Emitting error to context %s', ctx.name, err);
            ctx.emit('error', err);
            return;
        }
        // No context with error listeners found
        this._debug('No error handler is configured for the context chain', err);
        // Let it crash now by emitting an error event
        this.emit('error', err);
    }
    /**
     * Start a background task to listen on context events and notify observers
     */
    startNotificationTask() {
        // Set up listeners on `bind` and `unbind` for notifications
        this.setupNotification('bind', 'unbind');
        // Create an async iterator for the `notification` event as a queue
        this.notificationQueue = p_event_1.iterator(this, 'notification');
        return this.processNotifications();
    }
    /**
     * Process notification events as they arrive on the queue
     */
    async processNotifications() {
        var e_1, _a;
        const events = this.notificationQueue;
        if (events == null)
            return;
        try {
            for (var events_2 = __asyncValues(events), events_2_1; events_2_1 = await events_2.next(), !events_2_1.done;) {
                const { eventType, binding, context, observers } = events_2_1.value;
                // The loop will happen asynchronously upon events
                try {
                    // The execution of observers happen in the Promise micro-task queue
                    await this.notifyObservers(eventType, binding, context, observers);
                    this.pendingNotifications--;
                    this._debug('Observers notified for %s of binding %s', eventType, binding.key);
                    this.emit('observersNotified', { eventType, binding });
                }
                catch (err) {
                    this.pendingNotifications--;
                    this._debug('Error caught from observers', err);
                    // Errors caught from observers. Emit it to the current context.
                    // If no error listeners are registered, crash the process.
                    this.emit('error', err);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (events_2_1 && !events_2_1.done && (_a = events_2.return)) await _a.call(events_2);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * Listen on given event types and emit `notification` event. This method
     * merge multiple event types into one for notification.
     * @param eventTypes - Context event types
     */
    setupNotification(...eventTypes) {
        for (const eventType of eventTypes) {
            this.on(eventType, (binding, context) => {
                // No need to schedule notifications if no observers are present
                if (!this.observers || this.observers.size === 0)
                    return;
                // Track pending events
                this.pendingNotifications++;
                // Take a snapshot of current observers to ensure notifications of this
                // event will only be sent to current ones. Emit a new event to notify
                // current context observers.
                this.emit('notification', {
                    eventType,
                    binding,
                    context,
                    observers: new Set(this.observers),
                });
            });
        }
    }
    /**
     * Wait until observers are notified for all of currently pending notification
     * events.
     *
     * This method is for test only to perform assertions after observers are
     * notified for relevant events.
     */
    async waitUntilPendingNotificationsDone(timeout) {
        const count = this.pendingNotifications;
        if (count === 0)
            return;
        await p_event_1.multiple(this, 'observersNotified', { count, timeout });
    }
    /**
     * Create a binding with the given key in the context. If a locked binding
     * already exists with the same key, an error will be thrown.
     *
     * @param key - Binding key
     */
    bind(key) {
        const binding = new binding_1.Binding(key.toString());
        this.add(binding);
        return binding;
    }
    /**
     * Add a binding to the context. If a locked binding already exists with the
     * same key, an error will be thrown.
     * @param binding - The configured binding to be added
     */
    add(binding) {
        var _a;
        const key = binding.key;
        this._debug('[%s] Adding binding: %s', key);
        let existingBinding;
        const keyExists = this.registry.has(key);
        if (keyExists) {
            existingBinding = this.registry.get(key);
            const bindingIsLocked = (_a = existingBinding) === null || _a === void 0 ? void 0 : _a.isLocked;
            if (bindingIsLocked)
                throw new Error(`Cannot rebind key "${key}" to a locked binding`);
        }
        this.registry.set(key, binding);
        if (existingBinding !== binding) {
            if (existingBinding != null) {
                this.emit('unbind', existingBinding, this);
            }
            this.emit('bind', binding, this);
        }
        return this;
    }
    /**
     * Create a corresponding binding for configuration of the target bound by
     * the given key in the context.
     *
     * For example, `ctx.configure('controllers.MyController').to({x: 1})` will
     * create binding `controllers.MyController:$config` with value `{x: 1}`.
     *
     * @param key - The key for the binding to be configured
     */
    configure(key = '') {
        const bindingForConfig = binding_1.Binding.configure(key);
        this.add(bindingForConfig);
        return bindingForConfig;
    }
    /**
     * Get the value or promise of configuration for a given binding by key
     *
     * @param key - Binding key
     * @param propertyPath - Property path for the option. For example, `x.y`
     * requests for `<config>.x.y`. If not set, the `<config>` object will be
     * returned.
     * @param resolutionOptions - Options for the resolution.
     * - optional: if not set or set to `true`, `undefined` will be returned if
     * no corresponding value is found. Otherwise, an error will be thrown.
     */
    getConfigAsValueOrPromise(key, propertyPath, resolutionOptions) {
        this.setupConfigurationResolverIfNeeded();
        return this.configResolver.getConfigAsValueOrPromise(key, propertyPath, resolutionOptions);
    }
    /**
     * Set up the configuration resolver if needed
     */
    setupConfigurationResolverIfNeeded() {
        if (!this.configResolver) {
            // First try the bound ConfigurationResolver to this context
            const configResolver = this.getSync(keys_1.ContextBindings.CONFIGURATION_RESOLVER, {
                optional: true,
            });
            if (configResolver) {
                debug('Custom ConfigurationResolver is loaded from %s.', keys_1.ContextBindings.CONFIGURATION_RESOLVER.toString());
                this.configResolver = configResolver;
            }
            else {
                // Fallback to DefaultConfigurationResolver
                debug('DefaultConfigurationResolver is used.');
                this.configResolver = new binding_config_1.DefaultConfigurationResolver(this);
            }
        }
        return this.configResolver;
    }
    /**
     * Resolve configuration for the binding by key
     *
     * @param key - Binding key
     * @param propertyPath - Property path for the option. For example, `x.y`
     * requests for `<config>.x.y`. If not set, the `<config>` object will be
     * returned.
     * @param resolutionOptions - Options for the resolution.
     */
    async getConfig(key, propertyPath, resolutionOptions) {
        return this.getConfigAsValueOrPromise(key, propertyPath, resolutionOptions);
    }
    /**
     * Resolve configuration synchronously for the binding by key
     *
     * @param key - Binding key
     * @param propertyPath - Property path for the option. For example, `x.y`
     * requests for `config.x.y`. If not set, the `config` object will be
     * returned.
     * @param resolutionOptions - Options for the resolution.
     */
    getConfigSync(key, propertyPath, resolutionOptions) {
        const valueOrPromise = this.getConfigAsValueOrPromise(key, propertyPath, resolutionOptions);
        if (value_promise_1.isPromiseLike(valueOrPromise)) {
            const prop = propertyPath ? ` property ${propertyPath}` : '';
            throw new Error(`Cannot get config${prop} for ${key} synchronously: the value is a promise`);
        }
        return valueOrPromise;
    }
    /**
     * Unbind a binding from the context. No parent contexts will be checked.
     *
     * @remarks
     * If you need to unbind a binding owned by a parent context, use the code
     * below:
     *
     * ```ts
     * const ownerCtx = ctx.getOwnerContext(key);
     * return ownerCtx != null && ownerCtx.unbind(key);
     * ```
     *
     * @param key - Binding key
     * @returns true if the binding key is found and removed from this context
     */
    unbind(key) {
        var _a;
        this._debug('Unbind %s', key);
        key = binding_key_1.BindingKey.validate(key);
        const binding = this.registry.get(key);
        // If not found, return `false`
        if (binding == null)
            return false;
        if ((_a = binding) === null || _a === void 0 ? void 0 : _a.isLocked)
            throw new Error(`Cannot unbind key "${key}" of a locked binding`);
        this.registry.delete(key);
        this.emit('unbind', binding, this);
        return true;
    }
    /**
     * Add a context event observer to the context
     * @param observer - Context observer instance or function
     */
    subscribe(observer) {
        var _a;
        this.observers = (_a = this.observers, (_a !== null && _a !== void 0 ? _a : new Set()));
        this.setupEventHandlersIfNeeded();
        this.observers.add(observer);
        return new ContextSubscription(this, observer);
    }
    /**
     * Remove the context event observer from the context
     * @param observer - Context event observer
     */
    unsubscribe(observer) {
        if (!this.observers)
            return false;
        return this.observers.delete(observer);
    }
    /**
     * Close the context: clear observers, stop notifications, and remove event
     * listeners from its parent context.
     *
     * @remarks
     * This method MUST be called to avoid memory leaks once a context object is
     * no longer needed and should be recycled. An example is the `RequestContext`,
     * which is created per request.
     */
    close() {
        this._debug('Closing context...');
        this.observers = undefined;
        if (this.notificationQueue != null) {
            // Cancel the notification iterator
            this.notificationQueue.return(undefined).catch(err => {
                this.handleNotificationError(err);
            });
            this.notificationQueue = undefined;
        }
        if (this._parent && this._parentEventListeners) {
            for (const [event, listener] of this._parentEventListeners) {
                this._parent.removeListener(event, listener);
            }
            this._parentEventListeners = undefined;
        }
    }
    /**
     * Check if an observer is subscribed to this context
     * @param observer - Context observer
     */
    isSubscribed(observer) {
        if (!this.observers)
            return false;
        return this.observers.has(observer);
    }
    /**
     * Create a view of the context chain with the given binding filter
     * @param filter - A function to match bindings
     * @param comparator - A function to sort matched bindings
     */
    createView(filter, comparator) {
        const view = new context_view_1.ContextView(this, filter, comparator);
        view.open();
        return view;
    }
    /**
     * Publish an event to the registered observers. Please note the
     * notification is queued and performed asynchronously so that we allow fluent
     * APIs such as `ctx.bind('key').to(...).tag(...);` and give observers the
     * fully populated binding.
     *
     * @param eventType - Event names: `bind` or `unbind`
     * @param binding - Binding bound or unbound
     * @param context - Owner context
     * @param observers - Current set of context observers
     */
    async notifyObservers(eventType, binding, context, observers = this.observers) {
        if (!observers || observers.size === 0)
            return;
        for (const observer of observers) {
            if (typeof observer === 'function') {
                await observer(eventType, binding, context);
            }
            else if (!observer.filter || observer.filter(binding)) {
                await observer.observe(eventType, binding, context);
            }
        }
    }
    /**
     * Check if a binding exists with the given key in the local context without
     * delegating to the parent context
     * @param key - Binding key
     */
    contains(key) {
        key = binding_key_1.BindingKey.validate(key);
        return this.registry.has(key);
    }
    /**
     * Check if a key is bound in the context or its ancestors
     * @param key - Binding key
     */
    isBound(key) {
        if (this.contains(key))
            return true;
        if (this._parent) {
            return this._parent.isBound(key);
        }
        return false;
    }
    /**
     * Get the owning context for a binding key
     * @param key - Binding key
     */
    getOwnerContext(key) {
        if (this.contains(key))
            return this;
        if (this._parent) {
            return this._parent.getOwnerContext(key);
        }
        return undefined;
    }
    /**
     * Find bindings using a key pattern or filter function
     * @param pattern - A filter function, a regexp or a wildcard pattern with
     * optional `*` and `?`. Find returns such bindings where the key matches
     * the provided pattern.
     *
     * For a wildcard:
     * - `*` matches zero or more characters except `.` and `:`
     * - `?` matches exactly one character except `.` and `:`
     *
     * For a filter function:
     * - return `true` to include the binding in the results
     * - return `false` to exclude it.
     */
    find(pattern) {
        const bindings = [];
        const filter = binding_filter_1.filterByKey(pattern);
        for (const b of this.registry.values()) {
            if (filter(b))
                bindings.push(b);
        }
        const parentBindings = this._parent && this._parent.find(filter);
        return this._mergeWithParent(bindings, parentBindings);
    }
    /**
     * Find bindings using the tag filter. If the filter matches one of the
     * binding tags, the binding is included.
     *
     * @param tagFilter - A filter for tags. It can be in one of the following
     * forms:
     * - A regular expression, such as `/controller/`
     * - A wildcard pattern string with optional `*` and `?`, such as `'con*'`
     *   For a wildcard:
     *   - `*` matches zero or more characters except `.` and `:`
     *   - `?` matches exactly one character except `.` and `:`
     * - An object containing tag name/value pairs, such as
     * `{name: 'my-controller'}`
     */
    findByTag(tagFilter) {
        return this.find(binding_filter_1.filterByTag(tagFilter));
    }
    _mergeWithParent(childList, parentList) {
        if (!parentList)
            return childList;
        const additions = parentList.filter(parentBinding => {
            // children bindings take precedence
            return !childList.some(childBinding => childBinding.key === parentBinding.key);
        });
        return childList.concat(additions);
    }
    // Implementation
    async get(keyWithPath, optionsOrSession) {
        this._debug('Resolving binding: %s', keyWithPath);
        return this.getValueOrPromise(keyWithPath, optionsOrSession);
    }
    // Implementation
    getSync(keyWithPath, optionsOrSession) {
        this._debug('Resolving binding synchronously: %s', keyWithPath);
        const valueOrPromise = this.getValueOrPromise(keyWithPath, optionsOrSession);
        if (value_promise_1.isPromiseLike(valueOrPromise)) {
            throw new Error(`Cannot get ${keyWithPath} synchronously: the value is a promise`);
        }
        return valueOrPromise;
    }
    getBinding(key, options) {
        var _a;
        key = binding_key_1.BindingKey.validate(key);
        const binding = this.registry.get(key);
        if (binding) {
            return binding;
        }
        if (this._parent) {
            return this._parent.getBinding(key, options);
        }
        if ((_a = options) === null || _a === void 0 ? void 0 : _a.optional)
            return undefined;
        throw new Error(`The key '${key}' is not bound to any value in context ${this.name}`);
    }
    /**
     * Find or create a binding for the given key
     * @param key - Binding address
     * @param policy - Binding creation policy
     */
    findOrCreateBinding(key, policy) {
        let binding;
        if (policy === BindingCreationPolicy.ALWAYS_CREATE) {
            binding = this.bind(key);
        }
        else if (policy === BindingCreationPolicy.NEVER_CREATE) {
            binding = this.getBinding(key);
        }
        else if (this.isBound(key)) {
            // CREATE_IF_NOT_BOUND - the key is bound
            binding = this.getBinding(key);
        }
        else {
            // CREATE_IF_NOT_BOUND - the key is not bound
            binding = this.bind(key);
        }
        return binding;
    }
    /**
     * Get the value bound to the given key.
     *
     * This is an internal version that preserves the dual sync/async result
     * of `Binding#getValue()`. Users should use `get()` or `getSync()` instead.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * ctx.getValueOrPromise<Application>('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * ctx.getValueOrPromise<RestComponentConfig>('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * ctx.getValueOrPromise<number>('data#numbers.a');
     * ```
     *
     * @param keyWithPath - The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @param optionsOrSession - Options for resolution or a session
     * @returns The bound value or a promise of the bound value, depending
     *   on how the binding is configured.
     * @internal
     */
    getValueOrPromise(keyWithPath, optionsOrSession) {
        const { key, propertyPath } = binding_key_1.BindingKey.parseKeyWithPath(keyWithPath);
        optionsOrSession = resolution_session_1.asResolutionOptions(optionsOrSession);
        const binding = this.getBinding(key, optionsOrSession);
        if (binding == null)
            return undefined;
        const boundValue = binding.getValue(this, optionsOrSession);
        if (propertyPath === undefined || propertyPath === '') {
            return boundValue;
        }
        if (value_promise_1.isPromiseLike(boundValue)) {
            return boundValue.then(v => value_promise_1.getDeepProperty(v, propertyPath));
        }
        return value_promise_1.getDeepProperty(boundValue, propertyPath);
    }
    /**
     * Create a plain JSON object for the context
     */
    toJSON() {
        const bindings = {};
        for (const [k, v] of this.registry) {
            bindings[k] = v.toJSON();
        }
        return bindings;
    }
    /**
     * Inspect the context and dump out a JSON object representing the context
     * hierarchy
     */
    // TODO(rfeng): Evaluate https://nodejs.org/api/util.html#util_custom_inspection_functions_on_objects
    inspect() {
        const json = {
            name: this.name,
            bindings: this.toJSON(),
        };
        if (this._parent) {
            json.parent = this._parent.inspect();
        }
        return json;
    }
}
exports.Context = Context;
/**
 * An implementation of `Subscription` interface for context events
 */
class ContextSubscription {
    constructor(context, observer) {
        this.context = context;
        this.observer = observer;
        this._closed = false;
    }
    unsubscribe() {
        this.context.unsubscribe(this.observer);
        this._closed = true;
    }
    get closed() {
        return this._closed;
    }
}
/**
 * Policy to control if a binding should be created for the context
 */
var BindingCreationPolicy;
(function (BindingCreationPolicy) {
    /**
     * Always create a binding with the key for the context
     */
    BindingCreationPolicy["ALWAYS_CREATE"] = "Always";
    /**
     * Never create a binding for the context. If the key is not bound in the
     * context, throw an error.
     */
    BindingCreationPolicy["NEVER_CREATE"] = "Never";
    /**
     * Create a binding if the key is not bound in the context. Otherwise, return
     * the existing binding.
     */
    BindingCreationPolicy["CREATE_IF_NOT_BOUND"] = "IfNotBound";
})(BindingCreationPolicy = exports.BindingCreationPolicy || (exports.BindingCreationPolicy = {}));
//# sourceMappingURL=context.js.map