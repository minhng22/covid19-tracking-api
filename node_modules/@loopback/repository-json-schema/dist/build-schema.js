"use strict";
// Copyright IBM Corp. 2018,2019. All Rights Reserved.
// Node module: @loopback/repository-json-schema
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const repository_1 = require("@loopback/repository");
const debug_1 = __importDefault(require("debug"));
const util_1 = require("util");
const keys_1 = require("./keys");
const debug = debug_1.default('loopback:repository-json-schema:build-schema');
/**
 * @internal
 */
function buildModelCacheKey(options = {}) {
    var _a;
    // Backwards compatibility: preserve cache key "modelOnly"
    if (Object.keys(options).length === 0) {
        return "modelOnly" /* ModelOnly */;
    }
    // New key schema: use the same suffix as we use for schema title
    // For example: "modelPartialWithRelations"
    // Note this new key schema preserves the old key "modelWithRelations"
    return 'model' + (_a = options.title, (_a !== null && _a !== void 0 ? _a : '')) + getTitleSuffix(options);
}
exports.buildModelCacheKey = buildModelCacheKey;
/**
 * Gets the JSON Schema of a TypeScript model/class by seeing if one exists
 * in a cache. If not, one is generated and then cached.
 * @param ctor - Contructor of class to get JSON Schema from
 */
function getJsonSchema(ctor, options) {
    var _a;
    // In the near future the metadata will be an object with
    // different titles as keys
    const cached = context_1.MetadataInspector.getClassMetadata(keys_1.JSON_SCHEMA_KEY, ctor);
    const key = buildModelCacheKey(options);
    let schema = (_a = cached) === null || _a === void 0 ? void 0 : _a[key];
    if (!schema) {
        // Create new json schema from model
        // if not found in cache for specific key
        schema = modelToJsonSchema(ctor, options);
        if (cached) {
            // Add a new key to the cached schema of the model
            cached[key] = schema;
        }
        else {
            // Define new metadata and set in cache
            context_1.MetadataInspector.defineMetadata(keys_1.JSON_SCHEMA_KEY.key, { [key]: schema }, ctor);
        }
    }
    return schema;
}
exports.getJsonSchema = getJsonSchema;
/**
 * Describe the provided Model as a reference to a definition shared by multiple
 * endpoints. The definition is included in the returned schema.
 *
 * @example
 *
 * ```ts
 * const schema = {
 *   $ref: '/definitions/Product',
 *   definitions: {
 *     Product: {
 *       title: 'Product',
 *       properties: {
 *         // etc.
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param modelCtor - The model constructor (e.g. `Product`)
 * @param options - Additional options
 */
function getJsonSchemaRef(modelCtor, options) {
    const schemaWithDefinitions = getJsonSchema(modelCtor, options);
    const key = schemaWithDefinitions.title;
    // ctor is not a model
    if (!key)
        return schemaWithDefinitions;
    const definitions = Object.assign({}, schemaWithDefinitions.definitions);
    const schema = Object.assign({}, schemaWithDefinitions);
    delete schema.definitions;
    definitions[key] = schema;
    return {
        $ref: `#/definitions/${key}`,
        definitions,
    };
}
exports.getJsonSchemaRef = getJsonSchemaRef;
/**
 * Gets the wrapper function of primitives string, number, and boolean
 * @param type - Name of type
 */
function stringTypeToWrapper(type) {
    if (typeof type === 'function') {
        return type;
    }
    type = type.toLowerCase();
    let wrapper;
    switch (type) {
        case 'number': {
            wrapper = Number;
            break;
        }
        case 'string': {
            wrapper = String;
            break;
        }
        case 'boolean': {
            wrapper = Boolean;
            break;
        }
        case 'array': {
            wrapper = Array;
            break;
        }
        case 'object': {
            wrapper = Object;
            break;
        }
        case 'date': {
            wrapper = Date;
            break;
        }
        case 'buffer': {
            wrapper = Buffer;
            break;
        }
        default: {
            throw new Error('Unsupported type: ' + type);
        }
    }
    return wrapper;
}
exports.stringTypeToWrapper = stringTypeToWrapper;
/**
 * Determines whether a given string or constructor is array type or not
 * @param type - Type as string or wrapper
 */
function isArrayType(type) {
    return type === Array || type === 'array';
}
exports.isArrayType = isArrayType;
/**
 * Converts property metadata into a JSON property definition
 * @param meta
 */
function metaToJsonProperty(meta) {
    const propDef = {};
    let result;
    let propertyType = meta.type;
    if (isArrayType(propertyType) && meta.itemType) {
        if (Array.isArray(meta.itemType)) {
            throw new Error('itemType as an array is not supported');
        }
        result = { type: 'array', items: propDef };
        propertyType = meta.itemType;
    }
    else {
        result = propDef;
    }
    const wrappedType = stringTypeToWrapper(propertyType);
    const resolvedType = repository_1.resolveType(wrappedType);
    if (resolvedType === Date) {
        Object.assign(propDef, {
            type: 'string',
            format: 'date-time',
        });
    }
    else if (repository_1.isBuiltinType(resolvedType)) {
        Object.assign(propDef, {
            type: resolvedType.name.toLowerCase(),
        });
    }
    else {
        Object.assign(propDef, { $ref: `#/definitions/${resolvedType.name}` });
    }
    if (meta.description) {
        Object.assign(propDef, {
            description: meta.description,
        });
    }
    if (meta.jsonSchema) {
        Object.assign(propDef, meta.jsonSchema);
    }
    return result;
}
exports.metaToJsonProperty = metaToJsonProperty;
/**
 * Checks and return navigational property definition for the relation
 * @param relMeta Relation metadata object
 * @param targetRef Schema definition for the target model
 */
function getNavigationalPropertyForRelation(relMeta, targetRef) {
    if (relMeta.targetsMany === true) {
        // Targets an array of object, like, hasMany
        return {
            type: 'array',
            items: targetRef,
        };
    }
    else if (relMeta.targetsMany === false) {
        // Targets single object, like, hasOne, belongsTo
        return targetRef;
    }
    else {
        // targetsMany is undefined or null
        // not allowed if includeRelations is true
        throw new Error(`targetsMany attribute missing for ${relMeta.name}`);
    }
}
exports.getNavigationalPropertyForRelation = getNavigationalPropertyForRelation;
function buildSchemaTitle(ctor, meta, options) {
    if (options.title)
        return options.title;
    const title = meta.title || ctor.name;
    return title + getTitleSuffix(options);
}
/**
 * Checks the options and generates a descriptive suffix using compatible chars
 * @param options json schema options
 */
function getTitleSuffix(options = {}) {
    let suffix = '';
    if (options.optional && options.optional.length) {
        suffix += `Optional_${options.optional.join('-')}_`;
    }
    else if (options.partial) {
        suffix += 'Partial';
    }
    if (options.exclude && options.exclude.length) {
        suffix += `Excluding_${options.exclude.join('-')}_`;
    }
    if (options.includeRelations) {
        suffix += 'WithRelations';
    }
    return suffix;
}
function stringifyOptions(modelSettings = {}) {
    return util_1.inspect(modelSettings, {
        depth: Infinity,
        maxArrayLength: Infinity,
        breakLength: Infinity,
    });
}
function isEmptyJson(obj) {
    return !(obj && Object.keys(obj).length);
}
/**
 * Checks the options and generates a descriptive suffix
 * @param options json schema options
 */
function getDescriptionSuffix(rawOptions = {}) {
    const options = Object.assign({}, rawOptions);
    delete options.visited;
    if (options.optional && !options.optional.length) {
        delete options.optional;
    }
    return !isEmptyJson(options)
        ? `(Schema options: ${stringifyOptions(options)})`
        : '';
}
// NOTE(shimks) no metadata for: union, optional, nested array, any, enum,
// string literal, anonymous types, and inherited properties
/**
 * Converts a TypeScript class into a JSON Schema using TypeScript's
 * reflection API
 * @param ctor - Constructor of class to convert from
 */
function modelToJsonSchema(ctor, jsonSchemaOptions = {}) {
    var _a, _b, _c, _d, _e;
    const options = Object.assign({}, jsonSchemaOptions);
    options.visited = (_a = options.visited, (_a !== null && _a !== void 0 ? _a : {}));
    options.optional = (_b = options.optional, (_b !== null && _b !== void 0 ? _b : []));
    const partial = options.partial && !options.optional.length;
    if (options.partial && !partial) {
        debug('Overriding "partial" option with "optional" option');
        delete options.partial;
    }
    debug('Creating schema for model %s', ctor.name);
    debug('JSON schema options: %o', options);
    const meta = repository_1.ModelMetadataHelper.getModelMetadata(ctor);
    // returns an empty object if metadata is an empty object
    if (!(meta instanceof repository_1.ModelDefinition)) {
        return {};
    }
    debug('Model settings', meta.settings);
    const title = buildSchemaTitle(ctor, meta, options);
    if (options.visited[title])
        return options.visited[title];
    const result = { title };
    options.visited[title] = result;
    const descriptionSuffix = getDescriptionSuffix(options);
    if (meta.description) {
        const formatSuffix = descriptionSuffix ? ` ${descriptionSuffix}` : '';
        result.description = meta.description + formatSuffix;
    }
    else if (descriptionSuffix) {
        result.description = descriptionSuffix;
    }
    for (const p in meta.properties) {
        if (options.exclude && options.exclude.includes(p)) {
            continue;
        }
        if (!meta.properties[p].type) {
            continue;
        }
        result.properties = (_c = result.properties, (_c !== null && _c !== void 0 ? _c : {}));
        result.properties[p] = result.properties[p] || {};
        const metaProperty = Object.assign({}, meta.properties[p]);
        // populating "properties" key
        result.properties[p] = metaToJsonProperty(metaProperty);
        // handling 'required' metadata
        const optional = options.optional.includes(p);
        if (metaProperty.required && !(partial || optional)) {
            result.required = (_d = result.required, (_d !== null && _d !== void 0 ? _d : []));
            result.required.push(p);
        }
        // populating JSON Schema 'definitions'
        // shimks: ugly type casting; this should be replaced by logic to throw
        // error if itemType/type is not a string or a function
        const resolvedType = repository_1.resolveType(metaProperty.type);
        const referenceType = isArrayType(resolvedType)
            ? // shimks: ugly type casting; this should be replaced by logic to throw
                // error if itemType/type is not a string or a function
                repository_1.resolveType(metaProperty.itemType)
            : resolvedType;
        if (typeof referenceType !== 'function' || repository_1.isBuiltinType(referenceType)) {
            continue;
        }
        const propSchema = getJsonSchema(referenceType, options);
        includeReferencedSchema(referenceType.name, propSchema);
    }
    result.additionalProperties = meta.settings.strict === false;
    debug('  additionalProperties?', result.additionalProperties);
    if (options.includeRelations) {
        for (const r in meta.relations) {
            result.properties = (_e = result.properties, (_e !== null && _e !== void 0 ? _e : {}));
            const relMeta = meta.relations[r];
            const targetType = repository_1.resolveType(relMeta.target);
            const targetSchema = getJsonSchema(targetType, options);
            const targetRef = { $ref: `#/definitions/${targetSchema.title}` };
            const propDef = getNavigationalPropertyForRelation(relMeta, targetRef);
            result.properties[relMeta.name] =
                result.properties[relMeta.name] || propDef;
            includeReferencedSchema(targetSchema.title, targetSchema);
        }
    }
    function includeReferencedSchema(name, schema) {
        var _a, _b;
        if (!schema || !Object.keys(schema).length)
            return;
        // promote nested definition to the top level
        if (result !== schema && schema.definitions) {
            for (const key in schema.definitions) {
                if (key === title)
                    continue;
                result.definitions = (_a = result.definitions, (_a !== null && _a !== void 0 ? _a : {}));
                result.definitions[key] = schema.definitions[key];
            }
            delete schema.definitions;
        }
        if (result !== schema) {
            result.definitions = (_b = result.definitions, (_b !== null && _b !== void 0 ? _b : {}));
            result.definitions[name] = schema;
        }
    }
    return result;
}
exports.modelToJsonSchema = modelToJsonSchema;
//# sourceMappingURL=build-schema.js.map